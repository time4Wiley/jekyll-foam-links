# frozen_string_literal: true

require "jekyll"

module Jekyll
  module FoamLinks
    # Hook into the document processing pipeline
    Jekyll::Hooks.register [:pages, :documents], :pre_render do |doc|
      # Only process markdown files
      next unless doc.extname == ".md"
      
      # Get the document content
      content = doc.content
      
      # Regular expressions for matching wikilinks
      wikilink_regex = /\[\[([^\]]+)\]\]/
      embed_regex = /!\[\[([^\]]+)\]\]/
      
      # Find all wikilinks and embedded wikilinks
      wikilinks = content.scan(wikilink_regex).flatten
      embeds = content.scan(embed_regex).flatten
      
      # Combine and deduplicate
      all_links = (wikilinks + embeds).uniq
      
      # Skip if no wikilinks found
      next if all_links.empty?
      
      # Get the site to access all documents
      site = doc.site
      all_documents = site.pages + site.collections.values.flat_map(&:docs)
      
      # Filter to only markdown files
      markdown_files = all_documents.select { |d| d.extname == ".md" }
      
      # Generate reference definitions
      definitions = []
      link_replacements = {}
      
      all_links.each do |link|
        # Clean the link text
        link_text = link.strip
        
        # Find the target document
        target = find_target_document(link_text, markdown_files)
        
        if target
          # Generate relative path
          relative_path = generate_relative_path(doc, target)
          
          # Get the title from the target document
          title = extract_title(target)
          
          # Create the definition
          definition = format_definition(link_text, relative_path, title)
          definitions << definition
          
          # Store replacement for wikilink
          link_replacements[link_text] = { path: relative_path, title: title }
        else
          # For non-existent links, create placeholder definition
          definition = "[#{link_text}]: #{link_text} \"#{link_text}\""
          definitions << definition
        end
      end
      
      # Skip if no wikilinks found
      next if all_links.empty?
      
      # Replace wikilinks with reference-style links
      new_content = content.dup
      
      # Replace regular wikilinks
      new_content.gsub!(wikilink_regex) do |match|
        link_text = $1.strip
        "[#{link_text}]"
      end
      
      # Replace embedded wikilinks
      new_content.gsub!(embed_regex) do |match|
        link_text = $1.strip
        "![#{link_text}]"
      end
      
      # Add reference definitions at the end
      reference_section = [
        "",
        '[//begin]: # "Autogenerated link references for markdown compatibility"',
        definitions.join("\n"),
        '[//end]: # "Autogenerated link references"'
      ].join("\n")
      
      # Update the document content for rendering only
      doc.content = new_content + "\n" + reference_section
      
      Jekyll.logger.debug "Foam Link References:", "Processed #{doc.relative_path}"
    end
    
    private
    
    def self.find_target_document(link_text, all_documents)
      # Remove any path components from the link
      basename = File.basename(link_text, ".*")
      
      # Find matching document by basename
      all_documents.find do |doc|
        doc_basename = File.basename(doc.basename, ".*")
        doc_basename == basename || doc.data["slug"] == basename
      end
    end
    
    def self.generate_relative_path(source, target)
      source_dir = File.dirname(source.relative_path)
      target_path = target.relative_path
      
      # Calculate relative path
      relative = Pathname.new(target_path).relative_path_from(Pathname.new(source_dir))
      
      # Remove .md extension for compatibility
      path = relative.to_s.gsub(/\.md$/, '')
      
      # Handle spaces in filenames
      if path.include?(' ')
        path
      else
        path
      end
    end
    
    def self.extract_title(document)
      # Try to get title from front matter first
      if document.data["title"]
        document.data["title"]
      else
        # Try to get title from content
        content = document.content
        h1_match = content.match(/^#\s+(.+)$/m)
        
        if h1_match
          h1_match[1].strip
        else
          # Use filename without extension as title
          File.basename(document.basename, ".*").gsub(/[-_]/, ' ').capitalize
        end
      end
    end
    
    def self.format_definition(label, url, title)
      # Handle URLs with spaces
      if url.include?(' ')
        "[#{label}]: <#{url}> \"#{title}\""
      else
        "[#{label}]: #{url} \"#{title}\""
      end
    end
  end
end